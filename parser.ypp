%{

#include <stdio.h>
#include <stdlib.h>
#include <iostream>
#include "monDessin.h"
#include <QtGui>
#include <QApplication>
#include <algorithm>

#include "rectangle.h"
#include "cercle.h"
#include "ligne.h"


#define YYERROR_VERBOSE
#define USE(VALUE) /*empty*/


extern "C" int yyparse (void);
extern "C" int yylex(void);
extern "C" void yyerror(const std::string&);
extern FILE* yyin;

QPointer<monDessin> D;
%}

%union{
    char * texte;
    int valeur_entiere;
}

%token<valeur_entiere> ENTIER
%token<texte> CERCLE
%token<texte> RECTANGLE
%token<texte> LIGNE

%token<texte> COLOR
%token<texte> FILLING

%token<valeur_entiere> EPAISSEUR
%token<texte> COULEUR
%token<valeur_entiere> OPACITE
%token<valeur_entiere> ROTATION
%token<texte> REMPLISSAGE
%token<texte> IDENTIFICATEUR
%token VIRGULE
%token DEGRE
%token POURCENT
%token PARENTHESE_OUVRANTE
%token PARENTHESE_FERMANTE
%token ACCOLADE_OUVRANTE
%token ACCOLADE_FERMANTE
%token CROCHET_OUVRANT
%token CROCHET_FERMANT
%token EGAL
%token FENETRE
%token<valeur_entiere> LONGUEUR
%token<valeur_entiere> HAUTEUR
%token FIN_LIGNE
%token HASHTAG
%token COMMENTAIRE_MONO
%token COMMENTAIRE_MULTI


%type<texte> Forme

%start Input
%%
Input: 

	{
		std::cout << "Fin du fichier atteinte - Arrêt du parsing" << std::endl;
	}
	|FIN_LIGNE Input
	|COMMENTAIRE_MONO Input
	|COMMENTAIRE_MULTI Input
	|syntaxe_monoligne Input
	|syntaxe_multiligne Input
	|syntaxe_identifiant Input
	|option_identifiant Input
	|syntaxe_fenetre Input

syntaxe_monoligne: 
	Instanciation ACCOLADE_OUVRANTE COLOR VIRGULE ENTIER VIRGULE FILLING VIRGULE ENTIER DEGRE VIRGULE ENTIER POURCENT ACCOLADE_FERMANTE
	{
		// On récupère la forme courante pour appliquer les options
		Forme *f = D->currentShape();
		f->set_color($3);
		f->set_thickness($5);
		if (strcmp($7,"plein") == 0)
		{
			std::cout << "On remplit = " << $3 << std::endl;
			f->set_filling(PLEIN);
		}
		f->set_rotation($9);
		f->set_opacity($12);
	}

syntaxe_multiligne: 
	Instanciation ACCOLADE_OUVRANTE FIN_LIGNE
	Option_multiligne
	Option_multiligne
	Option_multiligne
	Option_multiligne
	Option_multiligne
	ACCOLADE_FERMANTE

Option_multiligne:
	COULEUR EGAL COLOR FIN_LIGNE
	{
		// On récupère la forme courante pour appliquer les options
		Forme *f = D->currentShape();
		f->set_color($3);
	}
	|ROTATION EGAL ENTIER DEGRE FIN_LIGNE
	{
		// On récupère la forme courante pour appliquer les options
		Forme *f = D->currentShape();
		f->set_rotation($3);
	}
	|REMPLISSAGE EGAL FILLING FIN_LIGNE
	{	
		// On récupère la forme courante pour appliquer les options
		Forme *f = D->currentShape();
		if (strcmp($3,"plein") == 0)
		{
			std::cout << "On remplit = " << $3 << std::endl;
			f->set_filling(PLEIN);
		}
	}
	|EPAISSEUR EGAL ENTIER FIN_LIGNE
	{
		// On récupère la forme courante pour appliquer les options
		Forme *f = D->currentShape();
		f->set_thickness($3);
	}
	|OPACITE EGAL ENTIER POURCENT FIN_LIGNE
	{
		// On récupère la forme courante pour appliquer les options
		Forme *f = D->currentShape();
		f->set_opacity($3);
	}

syntaxe_identifiant: 
	Forme IDENTIFICATEUR PARENTHESE_OUVRANTE ENTIER VIRGULE ENTIER VIRGULE ENTIER VIRGULE ENTIER PARENTHESE_FERMANTE FIN_LIGNE	
	{
		Ligne *l = new Ligne($4,$6,$8,$10);
		D->m_formes.push_back(l);
	}

option_identifiant:
	IDENTIFICATEUR CROCHET_OUVRANT EPAISSEUR CROCHET_FERMANT EGAL ENTIER
	|IDENTIFICATEUR CROCHET_OUVRANT COULEUR CROCHET_FERMANT EGAL COLOR

syntaxe_fenetre:
	FENETRE CROCHET_OUVRANT LONGUEUR CROCHET_FERMANT EGAL ENTIER
	{
		D->m_longueur = $6;
		std::cout << "Longueur = " << D->m_longueur << " $6 = " << $6 << std::endl;
	}
	|FENETRE CROCHET_OUVRANT HAUTEUR CROCHET_FERMANT EGAL ENTIER
	{
		D->m_hauteur = $6;
		std::cout << "Hauteur = " << D->m_hauteur << " $6 = " << $6 << std::endl;
	}
	|FENETRE CROCHET_OUVRANT COULEUR CROCHET_FERMANT EGAL COLOR

Forme:
	RECTANGLE
	|LIGNE



Instanciation:
	CERCLE PARENTHESE_OUVRANTE ENTIER VIRGULE ENTIER VIRGULE ENTIER PARENTHESE_FERMANTE
	{
		Cercle *c = new Cercle($3,$5,$7);
		D->m_formes.push_back(c);
	}
	|Forme PARENTHESE_OUVRANTE ENTIER VIRGULE ENTIER VIRGULE ENTIER VIRGULE ENTIER PARENTHESE_FERMANTE
	{
		std::string nomForme($1);
		std::transform(nomForme.begin(), nomForme.end(), nomForme.begin(), ::tolower);

		if(nomForme == "rectangle")
		{
			Rectangle *r = new Rectangle($3,$5,$7,$9);
			D->m_formes.push_back(r);	
		}
		else if(nomForme == "ligne")
		{
			Ligne *l = new Ligne($3,$5,$7,$9);
			D->m_formes.push_back(l);
		}
	}

%%


void trace(QMainWindow * w){
	yyin = fopen("forme.txt", "r");
	D = new monDessin;	
	w->setCentralWidget(D);
    	w->setMinimumSize(800, 600);
    // On remplit les attributs au cas où ils ne sont pas fournis dans le fichier texte
    D->m_longueur = 800;
    D->m_hauteur = 600;
	yyparse();
	w->resize(D->m_longueur, D->m_hauteur);
	D->draw();
	w->show();
	return	;
}



void yyerror(const std::string& mess){
    std::cout << mess << std::endl;
}